"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runServiceHook = runServiceHook;
exports.runOnPrepareHook = runOnPrepareHook;
exports.runOnCompleteHook = runOnCompleteHook;
exports.getRunnerName = getRunnerName;
exports.findInConfig = findInConfig;
exports.replaceConfig = replaceConfig;
exports.addServiceDeps = addServiceDeps;
exports.convertPackageHashToObject = convertPackageHashToObject;
exports.renderConfigurationFile = renderConfigurationFile;
exports.missingConfigurationPrompt = missingConfigurationPrompt;

var _fs = _interopRequireDefault(require("fs"));

var _ejs = _interopRequireDefault(require("ejs"));

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _child_process = require("child_process");

var _util = require("util");

var _constants = require("./constants");

var _inquirer = _interopRequireDefault(require("inquirer"));

var _config = require("./commands/config");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logger.default)('@wdio/cli:utils');

async function runServiceHook(launcher, hookName, ...args) {
  try {
    return await Promise.all(launcher.map(service => {
      if (typeof service[hookName] === 'function') {
        return service[hookName](...args);
      }
    }));
  } catch (e) {
    log.error(`A service failed in the '${hookName}' hook\n${e.stack}\n\nContinue...`);
  }
}

async function runOnPrepareHook(onPrepareHook, config, capabilities) {
  const catchFn = e => log.error(`Error in onPrepareHook: ${e.stack}`);

  if (typeof onPrepareHook === 'function') {
    onPrepareHook = [onPrepareHook];
  }

  return Promise.all(onPrepareHook.map(hook => {
    try {
      return hook(config, capabilities);
    } catch (e) {
      return catchFn(e);
    }
  })).catch(catchFn);
}

async function runOnCompleteHook(onCompleteHook, config, capabilities, exitCode, results) {
  if (typeof onCompleteHook === 'function') {
    onCompleteHook = [onCompleteHook];
  }

  return Promise.all(onCompleteHook.map(async hook => {
    try {
      await hook(exitCode, config, capabilities, results);
      return 0;
    } catch (e) {
      log.error(`Error in onCompleteHook: ${e.stack}`);
      return 1;
    }
  }));
}

function getRunnerName(caps = {}) {
  let runner = caps.browserName || caps.appPackage || caps.appWaitActivity || caps.app || caps.platformName;

  if (!runner) {
    runner = Object.values(caps).length === 0 || Object.values(caps).some(cap => !cap.capabilities) ? 'undefined' : 'MultiRemote';
  }

  return runner;
}

function buildNewConfigArray(str, type, change) {
  const newStr = str.split(`${type}s: `)[1].replace('\'', '');
  let newArray = newStr.match(/(\w*)/gmi).filter(e => !!e).concat([change]);
  return str.replace('// ', '').replace(new RegExp(`(${type}s: )((.*\\s*)*)`), `$1[${newArray.map(e => `'${e}'`)}]`);
}

function buildNewConfigString(str, type, change) {
  return str.replace(new RegExp(`(${type}: )('\\w*')`), `$1'${change}'`);
}

function findInConfig(config, type) {
  let regexStr = `[\\/\\/]*[\\s]*${type}s: [\\s]*\\[([\\s]*['|"]\\w*['|"],*)*[\\s]*\\]`;

  if (type === 'framework') {
    regexStr = `[\\/\\/]*[\\s]*${type}: ([\\s]*['|"]\\w*['|"])`;
  }

  const regex = new RegExp(regexStr, 'gmi');
  return config.match(regex);
}

function replaceConfig(config, type, name) {
  const match = findInConfig(config, type);

  if (!match || match.length === 0) {
    return;
  }

  if (type === 'framework') {
    return buildNewConfigString(config, type, name);
  }

  const text = match.pop();
  return config.replace(text, buildNewConfigArray(text, type, name));
}

function addServiceDeps(names, packages, update) {
  if (names.some(({
    short
  }) => short === 'chromedriver')) {
    packages.push('chromedriver');

    if (update) {
      console.log('\n=======', '\nPlease change path to / in your wdio.conf.js:', "\npath: '/'", '\n=======\n');
    }
  }

  if (names.some(({
    short
  }) => short === 'appium')) {
    const result = (0, _child_process.execSync)('appium --version || echo APPIUM_MISSING').toString().trim();

    if (result === 'APPIUM_MISSING') {
      packages.push('appium');
    } else if (update) {
      console.log('\n=======', '\nUsing globally installed appium', result, '\nPlease add the following to your wdio.conf.js:', "\nappium: { command: 'appium' }", '\n=======\n');
    }
  }
}

function convertPackageHashToObject(string, hash = '$--$') {
  const splitHash = string.split(hash);
  return {
    package: splitHash[0],
    short: splitHash[1]
  };
}

async function renderConfigurationFile(answers) {
  const renderFile = (0, _util.promisify)(_ejs.default.renderFile);

  const tplPath = _path.default.join(__dirname, 'templates/wdio.conf.tpl.ejs');

  const renderedTpl = await renderFile(tplPath, {
    answers
  });

  _fs.default.writeFileSync(_path.default.join(process.cwd(), 'wdio.conf.js'), renderedTpl);

  console.log(_constants.CONFIG_HELPER_SUCCESS_MESSAGE);
}

async function missingConfigurationPrompt(command, message, useYarn = false) {
  const {
    config
  } = await _inquirer.default.prompt([{
    type: 'confirm',
    name: 'config',
    message: `Error: Could not execute "${command}" due to missing configuration. Would you like to create one?`,
    default: false
  }]);

  if (!config && !process.env.JEST_WORKER_ID) {
    console.log(message);
    return process.exit(0);
  }

  return await (0, _config.runConfig)(useYarn, true);
}